# Maximum Subarray Sum  
### Naive vs Optimized (Kadaneâ€™s Algorithm)

ğŸ¥ **Project Video:**  
[Watch the explanation video](https://drive.google.com/file/d/1f1tnFPwwjtwsfjTfFcWo1CL4VQAxU50v/view?usp=sharing)

ğŸŒ **Live Version:**  
[Open Live Version](https://samahcodes.github.io/Algorithm/)

ğŸ‘©â€ğŸ’» **Team Members:**
Samah Mohamed Salah  â€” ID: 1000287603

Sahar Osama El-sieed â€” ID: 1000287997   

Sahar Reda Helmy â€” ID:  1000288192

Abdelrahman Mohamed â€” ID: 1000287467


ğŸ“˜ **Course:** Algorithms  
 

---

## ğŸ“– Project Overview

This project presents a comparative study of the **Maximum Subarray Sum Problem** using two approaches:
a naive (brute force) solution and an optimized solution based on **Kadaneâ€™s Algorithm**.

The project includes implementations, theoretical analysis, empirical analysis, and performance comparison.

---

## ğŸ§  Problem Identification

The Maximum Subarray Sum problem aims to determine the largest possible sum of a contiguous subarray within a given array of integers.

**Input:**  
- Array of integers (positive and negative values)

**Output:**  
- Maximum sum of a contiguous subarray

---

## ğŸ›  Implemented Algorithms

### ğŸ”´ Naive Solution (Brute Force)

The naive approach checks all possible contiguous subarrays and computes their sums to find the maximum value.

**Time Complexity:** O(nÂ²)  
**Space Complexity:** O(1)

ğŸ“· **Code Screenshot:**  
![Naive Solution Code](naiev%20code%20photo.jpg)

ğŸ“„ **Naive Solution Explanation (PDF):**  
[Open Naive Solution File](naive%20solution.pdf)

ğŸ“„ **Naive Solution Code (JavaScript):**  
[Open naievSolution.js](naievSolution.js)

---

### ğŸŸ¢ Optimized Solution (Kadaneâ€™s Algorithm)

The optimized solution uses a dynamic programming technique to efficiently compute the maximum subarray sum in a single pass.

**Time Complexity:** O(n)  
**Space Complexity:** O(1)

ğŸ“· **Code Screenshot:**  
![Optimized Solution Code](optamized%20code%20photo.jpg)

ğŸ“„ **Optimized Solution Explanation (PDF):**  
[Open Optimized Solution File](algo_pro_optimized.pdf)

ğŸ“„ **Optimized Solution Code (JavaScript):**  
[Open optamizedSolution.js](optamizedSolution.js)

---

## ğŸ“ Theoretical Analysis

The theoretical analysis explains the time and space complexity of both algorithms.

ğŸ“„ **Theoretical Analysis PDF:**  
[Open Theoretical Analysis](theoritical%20Analysis.pdf)

---

## ğŸ“Š Empirical Analysis

The empirical analysis evaluates the real execution time of both algorithms on inputs of varying sizes.

ğŸ“„ **Empirical Analysis PDF:**  
[Open Empirical Analysis](emprical%20analysis.pdf)

### Observations:
- Kadaneâ€™s algorithm shows linear growth in execution time.
- The naive solution becomes inefficient for large inputs.
- Empirical results confirm the theoretical analysis.
   **graph Screenshot:**  
![the graph](the%20graph.png)
---

## ğŸ” Comparison Summary

| Aspect | Naive | Optimized |
|------|------|-----------|
| Time Complexity | O(nÂ²) | O(n) |
| Performance | Slow | Fast |
| Scalability | Poor | Excellent |

---

## ğŸŒ Project Files

- `index.html` â€” Project live interface
- `style.css` â€” Styling file
- `script.js` â€” Script file
- `students.me` â€” Team information

---

## âœ… Conclusion

This project highlights the importance of algorithm optimization.
The optimized solution using Kadaneâ€™s Algorithm significantly outperforms the naive approach both theoretically and empirically.

---

âœ¨ *All files, code implementations, analysis documents, and project resources are included in this repository.*
